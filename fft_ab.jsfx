@init

// working_space must be 2*sizeB big
function fft_ab(block, sizeA, sizeB, working_space)
		local(i, j, twiddle_amount, twiddle_r, twiddle_i, index1, index2, tmp, N)
		(
	N = sizeA*sizeB;
	i = 0;
	// Perform the stepwise FFTs
	while (i < sizeA) (
		j = 0;
		// Copy to working area
		while (j < sizeB) (
			working_space[j*2] = block[i*2 + j*sizeA*2];
			working_space[j*2 + 1] = block[i*2 + j*sizeA*2 + 1];
			j += 1;
		);
		fft(working_space, sizeB);
		fft_permute(working_space, sizeB);
		// Copy back, with twiddle factors
		j = 0;
		while (j < sizeB) (
			twiddle_amount = i*j/N;
			twiddle_r = cos(twiddle_amount*2*$pi);
			twiddle_i = sin(twiddle_amount*2*$pi);
		
			block[i*2 + j*sizeA*2] = working_space[j*2]*twiddle_r - working_space[j*2 + 1]*twiddle_i;
			block[i*2 + j*sizeA*2 + 1] = working_space[j*2]*twiddle_i + working_space[j*2 + 1]*twiddle_r;
			j += 1;
		);

		i += 1;
	);
	
	// Perform the in-place FFTs
	j = 0;
	while (j < sizeB) (
		fft(block + j*sizeA*2, sizeA);
		fft_permute(block + j*sizeA*2, sizeA);
		j += 1;
	);
	
	// Permute
	i = 0;
	while (i < sizeA) (
		j = 0;
		while (j < sizeB) (
			index1 = i*sizeB + j;
			index2 = i + j*sizeA;

			tmp = block[index1*2];
			block[index1*2] = block[index2*2];
			block[index2*2] = tmp;
			tmp = block[index1*2 + 1];
			block[index1*2 + 1] = block[index2*2 + 1];
			block[index2*2 + 1] = tmp;
			j += 1;
		);
		i += 1;
	);
);

// working_space must be 2*sizeB big
function ifft_ab(block, sizeA, sizeB, working_space)
		local(i, j, twiddle_amount, twiddle_r, twiddle_i, index1, index2, tmp, N)
		(
	N = sizeA*sizeB;

	// Permute
	i = 0;
	while (i < sizeA) (
		j = 0;
		while (j < sizeB) (
			index1 = i*sizeB + j;
			index2 = i + j*sizeA;

			tmp = block[index1*2];
			block[index1*2] = block[index2*2];
			block[index2*2] = tmp;
			tmp = block[index1*2 + 1];
			block[index1*2 + 1] = block[index2*2 + 1];
			block[index2*2 + 1] = tmp;
			j += 1;
		);
		i += 1;
	);

	// Perform the in-place IFFTs
	j = 0;
	while (j < sizeB) (
		fft_ipermute(block + j*sizeA*2, sizeA);
		ifft(block + j*sizeA*2, sizeA);
		j += 1;
	);

	i = 0;
	// Perform the stepwise IFFTs
	while (i < sizeA) (
		j = 0;
		// Copy to working area
		while (j < sizeB) (
			working_space[j*2] = block[i*2 + j*sizeA*2];
			working_space[j*2 + 1] = block[i*2 + j*sizeA*2 + 1];
			j += 1;
		);
		fft_ipermute(working_space, sizeB);
		ifft(working_space, sizeB);
		// Copy back, dividing by twiddle factors
		j = 0;
		while (j < sizeB) (
			twiddle_amount = -i*j/N;
			twiddle_r = cos(twiddle_amount*2*$pi);
			twiddle_i = sin(twiddle_amount*2*$pi);
		
			block[i*2 + j*sizeA*2] = working_space[j*2]*twiddle_r - working_space[j*2 + 1]*twiddle_i;
			block[i*2 + j*sizeA*2 + 1] = working_space[j*2]*twiddle_i + working_space[j*2 + 1]*twiddle_r;
			j += 1;
		);

		i += 1;
	);
);
	
@block

original_block = 0;
fft_block = 65536;
native_block = 65536*2;
working_space = 65536*3;

i = 0;
while (i < 65536) (
	original_block[i] = fft_block[i] = native_block[i] = rand()*2 - 1;
	debug.original = original_block[i];
	debug.native = native_block[i];
	i += 1;
);

fft(native_block, 512);
//fft_permute(native_block, 512);

fft_ab(fft_block, 16, 32, working_space);

//fft_ipermute(native_block, 512);
ifft(native_block, 512);

ifft_ab(fft_block, 16, 32, working_space);

diff0 = fft_block[0]/original_block[0];
diff0b = native_block[0]/original_block[0];
