// working_space must be 2*sizeB big
function fft_ab(block, sizeA, sizeB, working_space)
    local(i, j, twiddle_amount, twiddle_r, twiddle_i, index1, index2, tmp, N)
    (
  N = sizeA*sizeB;
  i = 0;
  // Perform the stepwise FFTs
  while (i < sizeA) (
    j = 0;
    // Copy to working area
    while (j < sizeB) (
      working_space[j*2] = block[i*2 + j*sizeA*2];
      working_space[j*2 + 1] = block[i*2 + j*sizeA*2 + 1];
      j += 1;
    );
    fft_permute(working_space, sizeB);
    fft(working_space, sizeB);
    // Copy back, with twiddle factors
    j = 0;
    while (j < sizeB) (
      twiddle_amount = i*j/N;
      twiddle_r = cos(twiddle_amount*2*$pi);
      twiddle_i = sin(twiddle_amount*2*$pi);
    
      block[i*2 + j*sizeA*2] = working_space[j*2]*twiddle_r - working_space[j*2 + 1]*twiddle_i;
      block[i*2 + j*sizeA*2 + 1] = working_space[j*2]*twiddle_i + working_space[j*2 + 1]*twiddle_r;
      j += 1;
    );

    i += 1;
  );
  
  // Perform the in-place FFTs
  j = 0;
  while (j < sizeB) (
    fft_permute(block + j*sizeA*2, sizeA);
    fft(block + j*sizeA*2, sizeA);
    j += 1;
  );
  
  // Permute
  i = 0;
  while (i < sizeA) (
    j = 0;
    while (j < sizeB) (
      index1 = i*sizeB + j;
      index2 = i + j*sizeA;

      tmp = block[index1*2];
      block[index1*2] = block[index2*2];
      block[index2*2] = tmp;
      tmp = block[index1*2 + 1];
      block[index1*2 + 1] = block[index2*2 + 1];
      block[index2*2 + 1] = tmp;
      j += 1;
    );
    i += 1;
  );
);