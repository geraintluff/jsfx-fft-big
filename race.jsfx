desc:FFT test
slider1:8<8,20,1>2^N

@init

// working_space must be 2*sizeB big
function fft_ab(block, sizeA, sizeB, working_space)
		local(N, i, j, twiddle_amount, twiddle_r, twiddle_i, Nbits, shiftleftbits, shiftrightbits, bitmask, index1, source_index, target_index, bitmask, tmp_r, tmp_i)
		(
	N = sizeA*sizeB;
	i = 0;
	// Perform the stepwise FFTs
	while (i < sizeA) (
		j = 0;
		// Copy to working area
		while (j < sizeB) (
			working_space[j*2] = block[(i + j*sizeA)*2];
			working_space[j*2 + 1] = block[(i + j*sizeA)*2 + 1];
			j += 1;
		);
		fft(working_space, sizeB);
		fft_permute(working_space, sizeB);
		// Copy back, with twiddle factors
		j = 0;
		while (j < sizeB) (
			twiddle_amount = -i*j/N;
			twiddle_r = cos(twiddle_amount*2*$pi);
			twiddle_i = sin(twiddle_amount*2*$pi);
		
			block[(i + j*sizeA)*2] = working_space[j*2]*twiddle_r - working_space[j*2 + 1]*twiddle_i;
			block[(i + j*sizeA)*2 + 1] = working_space[j*2]*twiddle_i + working_space[j*2 + 1]*twiddle_r;
			j += 1;
		);

		i += 1;
	);
	
	// Perform the in-place FFTs
	j = 0;
	while (j < sizeB) (
		fft(block + j*sizeA*2, sizeA);
		fft_permute(block + j*sizeA*2, sizeA);
		j += 1;
	);
	
	// Permute
	Nbits = 1;
	while ((1<<Nbits) < N) (
		Nbits += 1;
	);
	shiftleftbits = 1; // This is the shift required to find the source index for a given target
	bitmask = N - 1;
	while ((1<<shiftleftbits) < sizeA) (
		shiftleftbits += 1;
	);
	shiftrightbits = Nbits - shiftleftbits;
	
	index1 = 1; // Source index
	while (index1 < N) (
		target_index = index1;
		while (
			target_index = ((target_index<<shiftleftbits)&bitmask) + (target_index>>shiftrightbits);
			target_index > index1;
		);
		target_index == index1 ? ( // This index is the shortest in its permutation group
			tmp_r = block[target_index*2];
			tmp_i = block[target_index*2 + 1];
			source_index = ((target_index<<shiftleftbits)&bitmask) + (target_index>>shiftrightbits);
			while (source_index != index1) (
				block[target_index*2] = block[source_index*2];
				block[target_index*2 + 1] = block[source_index*2 + 1];
				target_index = source_index;
				source_index = ((target_index<<shiftleftbits)&bitmask) + (target_index>>shiftrightbits);
			);
			block[target_index*2] = tmp_r;
			block[target_index*2 + 1] = tmp_i;
		);
		index1 += 1;
	);	
);

function fft_big(block, N, working_space) local(sizeB) (
	N > 32768 ? (
		sizeB = 1<<5;
		(N/sizeB) < 32768 ? sizeB = 1<<7;
		(N/sizeB) < 32768 ? sizeB = 1<<11;
		(N/sizeB) < 32768 ? sizeB = 1<<13;
		fft_ab(block, N/sizeB, sizeB, working_space);
	) : (
		fft(block, N);
		fft_permute(block, N);
	);
);

// working_space must be 2*sizeB big
function ifft_ab(block, sizeA, sizeB, working_space)
		local(N, i, j, twiddle_amount, twiddle_r, twiddle_i, Nbits, shiftleftbits, shiftrightbits, bitmask, index1, source_index, target_index, bitmask, tmp_r, tmp_i)
		(
	N = sizeA*sizeB;

	// Permute
	Nbits = 1;
	while ((1<<Nbits) < N) (
		Nbits += 1;
	);
	shiftleftbits = 1; // This is the shift required to find the source index for a given target
	bitmask = N - 1;
	while ((1<<shiftleftbits) < sizeB) ( // NOTE: the FFT uses sizeA, the IFFT uses sizeB (inverse shift)
		shiftleftbits += 1;
	);
	shiftrightbits = Nbits - shiftleftbits;
	
	index1 = 1; // Source index
	while (index1 < N) (
		target_index = index1;
		while (
			target_index = ((target_index<<shiftleftbits)&bitmask) + (target_index>>shiftrightbits);
			target_index > index1;
		);
		target_index == index1 ? ( // This index is the shortest in its permutation group
			tmp_r = block[target_index*2];
			tmp_i = block[target_index*2 + 1];
			source_index = ((target_index<<shiftleftbits)&bitmask) + (target_index>>shiftrightbits);
			while (source_index != index1) (
				block[target_index*2] = block[source_index*2];
				block[target_index*2 + 1] = block[source_index*2 + 1];
				target_index = source_index;
				source_index = ((target_index<<shiftleftbits)&bitmask) + (target_index>>shiftrightbits);
			);
			block[target_index*2] = tmp_r;
			block[target_index*2 + 1] = tmp_i;
		);
		index1 += 1;
	);

	// Perform the in-place IFFTs
	j = 0;
	while (j < sizeB) (
		fft_ipermute(block + j*sizeA*2, sizeA);
		ifft(block + j*sizeA*2, sizeA);
		j += 1;
	);

	i = 0;
	// Perform the stepwise IFFTs
	while (i < sizeA) (
		j = 0;
		// Copy to working area, with anti-twiddle factors
		while (j < sizeB) (
			twiddle_amount = i*j/N;
			twiddle_r = cos(twiddle_amount*2*$pi);
			twiddle_i = sin(twiddle_amount*2*$pi);
			
			working_space[j*2] = block[(i + j*sizeA)*2]*twiddle_r - block[(i + j*sizeA)*2 + 1]*twiddle_i;
			working_space[j*2 + 1] = block[(i + j*sizeA)*2]*twiddle_i + block[(i + j*sizeA)*2 + 1]*twiddle_r;
			j += 1;
		);
		fft_ipermute(working_space, sizeB);
		ifft(working_space, sizeB);
		j = 0;
		while (j < sizeB) (
			block[(i + j*sizeA)*2] = working_space[j*2];
			block[(i + j*sizeA)*2 + 1] = working_space[j*2 + 1];
			j += 1;
		);

		i += 1;
	); 
);

function ifft_big(block, N, working_space) local(sizeB) (
	N > 32768 ? (
		sizeB = 1<<5;
		(N/sizeB) < 32768 ? sizeB = 1<<7;
		(N/sizeB) < 32768 ? sizeB = 1<<11;
		(N/sizeB) < 32768 ? sizeB = 1<<13;
		ifft_ab(block, N/sizeB, sizeB, working_space);
	) : (
		fft_ipermute(block, N);
		ifft(block, N);
	);
);

timings_iterations = 0;

@block

fft_N = 1<<slider1;

fft_block = 0;
fft_block_end = fft_block + fft_N*2;

fft_ab_working_space = fft_block_end;
fft_ab_working_space_end = fft_ab_working_space + fft_N*2; // More than we need, but hey

timings = fft_ab_working_space_end;
sizeA = timings + 100;
sizeB = sizeA + 100;
timings_end = sizeB + 100;

(fft_N != last_fft_N || (mouse_cap&1)) ? (
	timings_iterations = 0;
	timings_counter = 0;
	timings_native = 0;
	while (timings_counter < 100) (
		timings[timings_counter] = 0;
		sizeA[timings_counter] = 0;
		sizeB[timings_counter] = 0;
		timings_counter += 1;
	);
);
last_fft_N = fft_N;

timings_iterations += 1;
timings_counter = 0;

function trySize(Nb) local(Na) (
	Na = fft_N/Nb;

	(Na <= 32768 && Na >= 16) ? (
		// Random complex input
		i = 0;
		while (i < fft_N) (
			fft_block_1[2*i] = fft_block_2[2*i] = 0;
			fft_block_1[2*i + 1] = fft_block_2[2*i + 1] = 0;
			i += 1;
		);
		fft_block_1[0] = fft_block_2[0] = 1;

		seconds = time_precise();
		fft_ab(fft_block, Na, Nb, fft_ab_working_space);
		timings[timings_counter] += time_precise() - seconds;
		sizeA[timings_counter] = Na;
		sizeB[timings_counter] = Nb;

		timings_counter += 1;
	);
);

trySize(1<<5);
trySize(1<<7);
trySize(1<<11);
trySize(1<<13);

(fft_N <= 32768) ? (
	seconds = time_precise();
	fft_permute(fft_block, fft_N);
	fft(fft_block, fft_N);
	timings_native += time_precise() - seconds;
);

timings_N = timings_counter;

@gfx

lowest = 10000000000;
gi = 0;
while (gi < timings_N) (
	lowest = min(timings[gi], lowest);
	gi += 1;
);

gfx_setfont(1, "Arial", 16);

gfx_r = gfx_g = gfx_b = 1;
gfx_x = gfx_y = gfx_texth;
gfx_printf("FFT size: %i", fft_N);
gfx_x = 200;
gfx_drawstr("(click to reset)");

gi = 0;
while (gi < timings_N) (
	gfx_r = gfx_g = gfx_b = 1;
	gfx_y = (gi*1.2 + 3)*gfx_texth;
	gfx_x = gfx_texth;
	
	timings[gi] == lowest ? (
		gfx_r = gfx_b = 0.5;
	);

	gfx_printf("%i x %i", sizeA[gi], sizeB[gi]);
	gfx_x = 100;
	gfx_printf("%0.3fms", timings[gi]/timings_iterations*1000);
	gfx_x = 200;
	gfx_printf("x%0.3f", timings[gi]/lowest);

	gi += 1;
);

	
fft_N <= 32768 ? (
	gfx_r = 0.5;
	gfx_g = 0.7;
	gfx_b = 1;
	
	gfx_x = gfx_texth;
	gfx_y += 2*gfx_texth;
	gfx_drawstr("native:");
	gfx_x = 100;
	gfx_printf("%0.3fms", timings_native/timings_iterations*1000);
	gfx_x = 200;
	gfx_printf("x%0.3f", timings_native/lowest);
);
